# Code
### 주요 비트 연산
- AND (&): 두 비트가 모두 1일 때만 결과가 1이 됩니다.
```rs
1010 & 1100 = 1000
```

- OR (|): 둘 중 하나라도 1이면 결과가 1이 됩니다.
```rs
1010 | 1100 = 1110
```

- XOR (^): 두 비트가 다를 때만 결과가 1이 됩니다.
```rs
1010 ^ 1100 = 0110
```

- NOT (~): 각 비트를 반전시킵니다. 0은 1로, 1은 0으로 바뀝니다.
```rs
~1010 = 0101

- 비트 쉬프트 연산: 비트를 왼쪽 또는 오른쪽으로 이동시키는 연산입니다.
```rs
1010 << 1 = 10100
1010 >> 1 = 0101
```

# 비트 연산의 예시
- 마스크 처리: 특정 비트들을 추출하거나 변경할 때 비트 마스크를 사용합니다.
```rs
let num = 0b10101100;
let mask = 0b00001111;
let result = num & mask; // 00001100
```

- 스왑 (비트 연산 기반 덧셈/뺄셈 없이)
```rs
a = a ^ b;
b = a ^ b;
a = a ^ b;
```

- 곱셈과 나눗셈: 왼쪽 쉬프트는 2의 거듭제곱으로 곱하는 역할을 하고, 오른쪽 쉬프트는 2의 거듭제곱으로 나누는 역할을 합니다.
```rs
5 << 1  => 10 (5 * 2)
20 >> 2 => 5  (20 / 4)
```

### ex00 adder 
```rs
pub fn adder(a: u32, b: u32) -> u32 {
    let res = a ^ b;
    let carry = (a & b) << 1;
    if carry == 0 {
        res
    } else {
        adder(res, carry)
    }
}
```
a + b를 비트 연산으로 구현하는 문제이다. 

### ex01 Multipliers
```rs
pub fn multiplier(a: u32, b: u32) -> u32 {
    if b == 0 {
        return 0;
    }
    if b & 1 == 0 {
        multiplier(a, b >> 1) << 1
    } else {
        adder(a, multiplier(a, b >> 1) << 1)
    }
}
```
3 * 4 = (3 * 2) *2 로 바꿀 수 있다.
3 * 5 = (3 * 4) + 3 로 바꿀 수 있다.

### ex02 gray code
- 그레이 코드의 특징은 인접한 숫자들 간에 오직 1비트만 다르다는 점
```rs
pub fn gray_code(n: u32) -> u32 {
    n ^ (n >> 1)
}
```
- n >> 1: n을 오른쪽으로 1비트 시프트합니다. 이는 n을 2로 나누는 것과 같습니다.
- n ^ (n >> 1): 원래 숫자 n과, n을 오른쪽으로 1비트 시프트한 값을 XOR 연산으로 결합합니다. XOR 연산은 두 비트가 다를 때 1이 되는 연산으로, 이 결과가 그레이 코드로 변환된 값이 됩니다.
- 그레이 코드는 특히 **엔코더(encoder)**나 디지털 회로에서 많이 사용됩니다. 예를 들어, 회전하는 엔코더에서 각도나 위치 정보를 읽을 때, 센서가 여러 신호를 동시에 받아들이면 오류가 발생할 수 있습니다. 그레이 코드를 사용하면 두 신호가 동시에 바뀌는 일이 없어서 안정적인 신호 처리가 가능합니다.
- 오류 검출: 데이터 전송이나 저장 중에 한 비트의 오류가 발생할 때 그레이 코드는 단일 비트 전환만 있기 때문에 오류를 쉽게 감지할 수 있습니다.
- 메모리 주소 할당: 메모리 시스템에서 하드웨어가 연속된 메모리 주소에 접근할 때, 그레이 코드를 사용하면 연속된 메모리 주소 간에 최소한의 비트 변화만 필요하게 되어 전환 과정에서 발생하는 전력 소모를 줄일 수 있습니다.

| Decimal (n) | Binary (n) | Binary (n >> 1) | Gray Code (n ^ (n >> 1)) |
|-------------|------------|-----------------|--------------------------|
| 0           | 0000       | 0000            | 0000                     |
| 1           | 0001       | 0000            | 0001                     |
| 2           | 0010       | 0001            | 0011                     |
| 3           | 0011       | 0001            | 0010                     |
| 4           | 0100       | 0010            | 0110                     |
| 5           | 0101       | 0010            | 0111                     |
| 6           | 0110       | 0011            | 0101                     |
| 7           | 0111       | 0011            | 0100                     |

### ex03 boolean evaluation

### ex04 truth table

### ex05 Negation Normal Form
- 부정연산을 변환함
- NNF 변환의 목표는 NOT 연산자가 개별 변수에만 적용되고, AND와 OR 연산자가 전체 식을 구성하도록 변환하는 것입니다. 이를 위해 드모르간 법칙을 사용하여 NOT이 AND와 OR 바깥으로 이동하고, 복잡한 논리식을 재구성.
- NNF에서 부정(!) 연산자는 항상 피연산자 바로 앞에 위치하며, AND (&)와 OR (|) 연산자만 사용됩니다. 
- 즉, 부정이 결합된 형태는 단일 변수나 리터럴 앞에만 존재해야 함.

### ex06 Conjunctive Normal
- Conjunctive Normal Form (CNF)는 논리식을 AND 연산자와 OR 연산자만을 사용하여 변환한 논리식.
    1. Negation Normal Form (NNF)으로 변환: 이미 구현된 to_nnf 함수를 사용하여 논리식을 NNF로 변환.
    2. 분배 법칙 적용: OR 연산자가 AND 연산자 안으로 분배되도록 논리식을 변환.
        - 변수와 부정만 있는 경우: 그대로 유지 예: !A, B 등.  
        - AND 연산자: 각각의 피연산자에 대해 재귀적으로 CNF를 적용.   
            예: A & B는 A & B로 유지.  
        - OR 연산자: 분배 법칙을 적용하여 OR 연산자가 AND 연산자 안으로 들어가도록 함  
            예: A | (B & C)는 (A | B) & (A | C)로 변환.  

#### 왜 cnf로 논리식을 변환하는가?
1. SAT 문제 해결을 위한 표준 형식
- CNF는 SAT(Satisfiability) 문제를 해결하기 위한 표준 형식
- SAT 문제는 주어진 논리식이 참이 되는지(만족 가능한지) 판단하는 문제로, 컴퓨터 과학에서 중요한 문제 중 하나입니다. CNF는 SAT 솔버(SAT solver)에서 사용되는 대표적인 형식이며, 효율적인 알고리즘이 이 형식을 기반으로 작동합니다.
- SAT 문제의 목표는 논리식을 만족시키는 변수 값을 찾는 것

2. 이론적 단순화 및 정리, 연산 최적화
CNF는 이론적으로 단순화된 형태의 논리식으로, 논리식을 단순하게 변환하는 방식 중 하나입니다. 여러 논리식을 동일한 형식으로 변환할 수 있기 때문에, 이 형식으로 변환함으로써 논리적 추론이 더 명확하고 쉬워집니다.
- 논리적 증명과 자동 정리 증명 등의 도구에서 표준 형식으로 많이 사용됩니다.

3. 디지털 회로 설계
디지털 회로 설계에서 논리식을 CNF로 변환하면, NAND 게이트(AND 게이트의 NOT 버전)와 같은 기본적인 논리 게이트들만으로 회로를 구성할 수 있습니다. 이는 하드웨어 설계에서 비용을 줄이고, 회로의 복잡성을 감소시키는 데 유리합니다.

4. 자동화된 논리 검증
프로그램의 모델 검증(model checking) 및 **형식적 검증(formal verification)**에서 논리식을 CNF로 변환하면, 시스템의 동작을 검증할 때 단순화된 형식으로 표현할 수 있습니다. 이는 시스템이 요구사항을 만족하는지, 논리적 오류가 없는지를 효율적으로 검증할 수 있게 합니다.


논리식 (A & B) & C는 다음과 같이 표현된다. 
```less
// 초기 상태 : ast 트리
Operator('&', 
    Operator('&', 
        Operand('A'), 
        Operand('B')
    ), 
    Operand('C')
)

// flatten_and 이후
[Operand('A'), Operand('B'), Operand('C')]
```

```rs
/// AND 연산자를 가진 노드들을 플랫하게 만드는 함수
fn flatten_and(ast: &ASTNode, nodes: &mut Vec<ASTNode>) {
    match ast {
        ASTNode::Operator('&', left, right) => {
            flatten_and(left, nodes);  // 왼쪽 자식을 재귀적으로 평탄화
            flatten_and(right, nodes); // 오른쪽 자식을 재귀적으로 평탄화
        }
        _ => nodes.push(ast.clone()),  // AND 연산자가 아닌 경우 단순히 벡터에 추가
    }
}
```
flatten_and 함수는 이를 [Operand('A'), Operand('B'), Operand('C')]와 같이 단순한 리스트로 변환. 변환된 리스트는 이후의 과정에서 다시 A & B & C 형태의 트리로 재구성됩니다.

### ex07 SAT

### ex08 powerset
1. 비트마스크를 이용한 부분집합 표현
```rs

pub fn powerset(set: &[i32]) -> Vec<Vec<i32>> {
    let mut result: Vec<Vec<i32>> = Vec::new();
    let n = set.len();

    // 2^n개의 부분집합을 생성
    for i in 0..(1 << n) {
        let mut subset: Vec<i32> = Vec::new();
        for j in 0..n {
            // i의 j번째 비트가 1인 경우, j번째 원소를 부분집합에 포함
            if i & (1 << j) != 0 {
                subset.push(set[j]);
            }
        }
        result.push(subset);
    }

    result
}
```

예를 들어, 집합이 [1, 2, 3]일 때, 각 i에 대해 비트로 표현된 패턴과 생성되는 부분집합은 다음과 같습니다:

i (10진수)	i (이진수)	부분집합
0	000	{}
1	001	{1}
2	010	{2}
3	011	{1, 2}
4	100	{3}
5	101	{1, 3}
6	110	{2, 3}
7	111	{1, 2, 3}
위 표에서 볼 수 있듯이, 각 숫자는 원소의 포함 여부를 나타내는 비트 패턴으로 변환되며, 그에 따라 부분집합이 결정됩니다.


2. 백트래킹
```rs

pub fn powerset(set: &[i32]) -> Vec<Vec<i32>> {
    let mut output = Vec::new();
    let n = set.len();
    
    // 부분집합의 크기를 0부터 n까지 증가시키면서 생성
    for k in 0..=n {
        let mut curr = Vec::new();
        backtrack(0, k, &mut curr, set, &mut output);
    }
    
    output
}

// 백트래킹을 통해 부분집합 생성
fn backtrack(first: usize, k: usize, curr: &mut Vec<i32>, set: &[i32], output: &mut Vec<Vec<i32>>) {
    // 현재 부분집합의 크기가 목표 크기(k)와 같으면 결과에 추가
    if curr.len() == k {
        output.push(curr.clone());
        return;
    }

    // 현재 인덱스 이후의 원소들을 탐색하여 부분집합 생성
    for i in first..set.len() {
        // 현재 원소를 부분집합에 추가
        curr.push(set[i]);
        
        // 다음 원소들로 백트래킹
        backtrack(i + 1, k, curr, set, output);
        
        // 백트래킹: 마지막 원소 제거
        curr.pop();
    }
}
```

### ex09 Set evaluations

### ex10 curve

### ex11 Inverse function 